# ch7 关联分析



# A. 关联规则挖掘



## I. 关联规则基本概念

- 设 $\mathbf{I} = \{i_1, i_2, \ldots, i_m\}$ 是所有项 (Item) $i_j \ (j = 1, 2, \ldots, m)$ 的集合
- $\mathbf{T}$ 是所有事务构成的集合: $\mathbf{T} = \{t_1, t_2, \ldots, t_N\}$, $\mathbf{T}$ 为 $\mathbf{I}$ 的一个非空子集，也称为事务标识符集合。每一个事务 $t_i$ 是一个项集，即 $t_i \subseteq \mathbf{I}$

- **关联规则形式化为** $P \rightarrow Q$ 的蕴含式，其中 $P \subseteq \mathbf{I}, Q \subseteq \mathbf{I}$，且 $P \cap Q = \emptyset$

- 数据库 $\mathbf{D}$ 包含所有事务的集合

- 项集可以看作是项的合取 (conjunction)

- **关联规则的主要目的** 是找出事务数据库中多次重复出现的项(item)之间的“关联”(association）

**例子**：购物篮问题

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240531205918.png" style="zoom:50%;" />

- **项** (item): 购物篮中的每一个商品
- **项集** (itemset): 购物篮中多个项组成的集合
  - 每个顾客购买的所有商品都是一个项集。其中，项集中项的个数称为项集的长度
- 定义 $\mathbf{I}$ 为所有项(商品)的集合，在上述例子中 $\mathbf{I}$ = {Bread, Jelly, Peanut, Butter, Milk, Chips}。
- **事务**(又称**交易，**transaction)，包含一个标识TID和购买的商品的集合
  -  $\mathbf{I}$ 的每个非空子集都称为一个**事务**（至少购买一件商品）。
  - 所有事务构成事务数据库 (记为 *D*)。
- 目的在于挖掘出如下形式的关联规则: Bread → Butter



## II. 规则兴趣度的两种度量

### 支持度

- 项（或项集）$X$ 的**支持度计数(频度或计数)**为数据库 $D$ 中包含项（或项集）$X$ 的事务的数目

- 项（或项集）$X$ 的**支持度 (sup)** 是包含项（或项集）$X$ 的事务数与总事务数 ($\#𝐷$)的比值 (有时项（或项集）$X$ 的支持度也记为 $sup(X, D)$, 简写为 $sup(X)$
  $$
  \text{sup}(X)=\dfrac{\#X}{\#D}
  $$

- **关联规则** 𝑋 → 𝑌 的**支持度计数**为同时包含项集X和Y的事务数。

- **规则的支持度(sup)**是数据库 *D* 中包含项集 X 和项集 Y 的事务数与数据库 *D* 中的事务数的比
  $$
  \text{sup}(X \rightarrow Y) = P(X \cup Y) = \frac{\#(X \cup Y)}{\#\mathbf{D}}
  $$
  其中 $\#(X \cup Y)$ 表示 $X$、$Y$ 两个项集同时发生的事务个数, $\#D$ 表示事务数据库 $D$ 的总数。(即同时购买 $X$ 和 $Y$ 的**频率**)

### 置信度

**规则的置信度 (conf)** 指在数据库 $\mathbf{D}$ 中同时包含两个项集 $\{X, Y\}$ 的事务个数与包含项集 $X$ 的事务个数的比率：
$$
\text{conf}(X \rightarrow Y) = \frac{\#(X \cup Y)}{\#(X)}
$$

其中 $\#(X)$ 表示事务数据库 $\mathbf{D}$ 中包含项集 $X$ 的事务个数。

**条件概率**：在出现了项集 $X$ 的事务 $T$ 中，项集 $Y$ 也同时出现的概率，即条件概率 $P(Y|X)$，即
$$
\text{conf}(X \rightarrow Y) = P(Y|X) = \frac{\#(X \cup Y)}{\#(X)}
$$

上述置信度可以等价地表示为
$$
\text{conf}(X \rightarrow Y) = \frac{\text{sup}(X \cup Y)}{\text{sup}(X)}
$$

### 支持度与置信度

- **支持度 (Support)** 度量了规则在事务数据集中出现的频率
- **置信度 (Confidence)** 度量了规则的强度

例子：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240531211736.png" style="zoom:50%;" />



## III. 频繁项集和强规则

- 为了筛选出那些具有较高支持度和置信度的规则，需要给这两个指标分别设定一个阈值。达到了阈值的规则才是有效规则。
- 支持度和置信度受到阈值的限制：
  - 最小支持度 $\sigma$（或记为 minsup）
  - 最小置信度 $\Phi$（或记为 minconf）

- **频繁项集** 是支持度大于 minsup 的项集，即满足 $\text{sup}(X) > \text{minsup}$ 的项集。
- 频繁 $k$ 项集的集合通常记为 $L_k$。
- **强关联规则（强规则）** 是一种同时满足最小支持度 (minsup) 和最小置信度 (minconf) 的规则（或者说条件概率大于 minconf），即满足
  $$
  \text{sup}(X \rightarrow Y) > \text{minsup} \ \text{且} \ \text{conf}(X \rightarrow Y) > \text{minconf}
  $$
  的规则。



## IV. 关联规则的挖掘定义

- 关联规则问题
  - 给定所有商品 $\mathbf{I}$，数据库 $\mathbf{D}$，两个阈值 $\sigma$ 和 $\Phi$，求出满足 $X \rightarrow Y$ 的所有强规则，即为关联规则的挖掘。
  - 数据挖掘主要就是对强规则的挖掘。

- 挖掘关联规则的一种原始方法是：**暴力法 (Brute-force approach)**
  - 计算每个可能规则的支持度和置信度。
  - 这种方法计算代价过高，因为可以从数据集提取的规则的数量达指数级。
  - 从包含 $d$ 个项的数据集提取的可能规则的总数 $R = 3^d - 2^{d+1} + 1$，如果 $d = 6$，则 $R = 602$。



## V. 关联规则挖掘的一般过程

- 大多数关联规则挖掘算法通常采用的一种策略是，将关联规则挖掘任务分解为如下两个主要的子任务：
  1. **生成频繁项集 (Frequent Itemset Generation)**
     - 其目标是发现**满足最小支持度阈值**的所有项集，这些项集称作频繁项集。

  2. **生成规则 (Rule Generation)**
     - 其目标是从上一步发现的频繁项集中**提取所有高置信度**的规则，这些规则称作强规则 (strong rule)。



## VI. 项集生成

### 原始暴力方法

- 把格结构中每个项集作为候选项集
- 将每个候选项集和每个事务进行比较，确定每个候选项集的支持度计数。
- 时间复杂度 ~ $O(NMW)$，这种方法的开销可能非常大。
- 如果有 $k$ 种商品, 所有可能的项集有 $M = 2^k - 1$ 次方个候选项集 (因为项集是非空子集, 故需要 -1), 需要探查的项集搜索空间是指数规模的

**格结构**（用来枚举所有可能的项集）：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240531224741.png" style="zoom:50%;" />

### 降低产生频繁项集计算复杂度的方法

- 减少候选项集的数量 (M)
  - Apriori算法-先验原理(Apriori principle) 
- 减少比较的次数 (NM)
  - 替代将每个候选项集与每个事务相匹配，可以使用更高级的数据结构，或存储候选项集或压缩数据集，来减少比较次数

### Aprior 算法

#### a. 关键思路（基于先验原理 aprior principle）

- **如果一个项集 X 是频繁的，则它的所有非空子集𝒀 ⊂ 𝑿一定也是频繁的**
  - {Milk, Bread} 是频繁的 → {Milk}, {Bread} 是频繁的
- **如果一个项集 X 是非频繁的，则它的所有超集𝒀 ⊃ 𝑿也一定是非频繁的**
  - {Coke} 是非频繁的 → {Milk, Coke} 是非频繁的

这种基于支持度度量修剪指数搜索空间的策略称为 **基于支持度的剪枝**（support-based pruning）

这种剪枝策略依赖于支持度度量的一个关键性质，即<u>**一个项集的支持度决不会超过它的子集的支持度**</u>。这个性质也称为**支持度度量的反单调性** (anti-monotone), 即 **support(X∪Y) ≤ support(X)** 

#### b. 候选修剪

如果 B 是非频繁项集, 那么包含B的项集(超集)都是非频繁的。

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601142933.png" style="zoom:50%;" />

**Apriori 算法采用的候选集生成策略**

1. Apriori算法假设事务或项集里的各项已经预先按字典顺序进行排列

2. 只对 $L_k$ 中那些 **<u>$X$ 和 $Y$ 前 $k-1$ 项相同且第 $k$ 项不同的频繁项集进行连接</u>**，生成 $C_{k+1}$ 的候选项集，连接方法如下： 

   候选项集产生： $\{X \cup Y \mid X, Y \in L_k, X_i = Y_i, \forall i \in [1, k-1], X_k \neq Y_k\}$         $\rightarrow$ **有序列表**

#### c. Apriori算法的一般过程

- 产生一个特定大小的项集 (如:每一个商品为一个项集)
- 扫描数据库一次以查看它们中的哪些是频繁的(去除非频繁的)
- 使用频繁项集来生成 size = size+1 的候选项集(单个商品两两组合)
- 迭代地找到基数从1到k的频繁项集
- 避免生成已知不频繁的候选项集

缺点：需要多次扫描数据库。高效的索引技术（hash, 位图）可能会有帮助。

#### d. Apriori算法伪代码

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601144342.png" style="zoom: 50%;" />

#### e. 算法总结

- **连接步**：候选 $k$-项集 $C_k$ 由频繁 $(k-1)$-项集 $L_{k-1}$ 与其自身连接生成。
- **剪枝步**：任意非频繁 $(k-1)$-项集不可能是一个频繁 $k$-项集的子集。

- Apriori 算法的频繁项集产生的部分有两个重要的特点：
  - 它是一个逐层算法。即从频繁 1-项集到最长的频繁项集，它每次遍历项集格中的一层。
  - 它使用产生-测试策略来发现频繁项集。在每次迭代，新候选项集由前一次迭代发现的频繁项集产生，然后对每个候选的支持度进行计数，并与最小支持度阈值进行比较。
  - 该算法需要的总迭代次数是 $k_{max} + 1$，其中 $k_{max}$ 是频繁项集的最大长度。

#### f. Apriori 算法例子

要求规则最小支持度=50%(即支持度计数≥2), 置信度≥70%

**生成频繁项集过程**：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601145359.png" style="zoom:50%;" />

**最终所有频繁项集**：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601145539.png" style="zoom:50%;" />

- $\{1, 3\}$ 产生规则：
  - ==$1 \rightarrow 3$ (sup = 2/4 = 50%, conf = 2/2 = 100%)==
  - $3 \rightarrow 1$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)

- $\{2, 3\}$ 产生规则：
  - $2 \rightarrow 3$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - $3 \rightarrow 2$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)

- $\{2, 5\}$ 产生规则：
  - ==$2 \rightarrow 5$ (sup = 3/4 = 75%, conf = 3/3 = 100%)==
  - ==$5 \rightarrow 2$ (sup = 3/4 = 75%, conf = 3/3 = 100%)==

- $\{3, 5\}$ 产生规则：
  - $3 \rightarrow 5$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - $5 \rightarrow 3$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)

- $\{2, 3, 5\}$ 产生规则：
  - $2 \rightarrow 3 \cup 5$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - $3 \rightarrow 2 \cup 5$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - $5 \rightarrow 2 \cup 3$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - ==$2 \cup 3 \rightarrow 5$ (sup = 2/4 = 50%, conf = 2/2 = 100%)==
  - $2 \cup 5 \rightarrow 3$ (sup = 2/4 = 50%, conf = 2/3 ≈ 66.7%)
  - ==$3 \cup 5 \rightarrow 2$ (sup = 2/4 = 50%, conf = 2/2 ≈ 100%)==

**强关联规则**：
- $1 \rightarrow 3$ (50%, 100%)
- $2 \rightarrow 5$ (75%, 100%)
- $5 \rightarrow 2$ (75%, 100%)
- $2 \cup 3 \rightarrow 5$ (50%, 100%)
- $3 \cup 5 \rightarrow 2$ (50%, 100%)





# B. 序列模式挖掘



## I. 序列挖掘基本概念

- 设 $I = \{i_1, i_2, \cdots, i_m\}$ 是所有项 (Item) $i_j \ (j = 1, 2, \ldots, m)$ 的集合。
- **序列**：元素（项集，事务）的有序列表
  - **元素/项集**：非空项集 $X \subseteq I$，表示序列 $s$ 为 $s = <s_1 s_2 \cdots s_n>$，其中 $s_i$ 是一个或多个项（事件）的集族，也叫作 $s$ 的一个元素（element）
  - 序列的一个元素（或项集）表示为 $\{x_1, x_2, \cdots, x_k\}$，其中 $x_j \in I$ 是一个项
  - 不失一般性，假设序列中元素的项是按**字典顺序**排列的
  - **大小 (size)**：序列的大小是序列中元素（或项集）的个数
  - **长度**：一个序列的长度是序列中所有项的个数。长度为 $k$ 的序列称为 $k$-序列
  - 称 $t = <t_1 t_2 \cdots t_m>$ 是 $s = <s_1 s_2 \cdots s_n>$ 的一个**子序列**如果存在整数 $1 \le j_1 < j_2 < \cdots < j_m \le n$ 使得 $t_1 \subseteq s_{j_1}$, $t_2 \subseteq s_{j_2}$, $\cdots$, $t_m \subseteq s_{j_m}$。我们也称 $s$ 是 $t$ 的**超序列**，或 $s$ **包含** $t$，记为 $t \subseteq s$。

**例子**：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601153221.png" style="zoom:50%;" />



## II. 序列挖掘的目标

- 设 $S$ 是包含一个或多个数据序列的数据集
- **数据序列** 是指与单个数据对象相关联的事件的有序列表
- **序列 $s$ 的支持度** 是包含 $s$ 的所有数据序列所占的比例
- **频繁序列（或序列模式）**：如果序列 $s$ 在序列数据库 $S$ 中的支持度大于或等于用户指定的最小支持度阈值，则称序列 $s$ 为**频繁序列（或序列模式）**
- **序列的支持度计数** 是 $S$ 中包含该序列的总数据序列个数
  - 长度为 1 的序列模式记为 1-模式
- **系统规定**：由于同一个元素中的项集之间排列次序没有顺序，为了表达的唯一性，我们将同一个元素内部的不同项集按照字典顺序排列

序列支持度的例子：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601154414.png" style="zoom:50%;" />



## III. 候选空间

- 候选序列的个数比候选项集的个数大得多。产生更多候选序列的原因有下面两个
  - 一个项在项集中最多出现一次，但一个事件可以在序列中出现多次。给定两个项 $i_1$ 和 $i_2$，只能产生一个候选 2-项集 $\{i_1, i_2\}$，但却可以产生许多候选 2-序列，如 $<\{i_1\}, \{i_2\}>$、$<\{i_1, i_2\}>$、$<\{i_2\}, \{i_1\}>$。
  - 次序在序列中是重要的，但在项集中不重要。例如，$\{i_1, i_2\}$ 和 $\{i_2, i_1\}$ 表示同一个项集，而 $<\{i_1\}, \{i_2\}>$ 和 $<\{i_2\}, \{i_1\}>$ 对应于不同的序列，因此必须分别产生。
- 先验原理（Apriori 算法）对序列数据成立
  - <u>如果一个 $k$-序列是频繁的，则它的所有 $(k-1)$-子序列也一定是频繁的。</u>



## IV. 序列模式的Apriori算法

### 算法伪代码

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601155343.png" style="zoom: 33%;" />



### 候选生成

一对频繁(k-1)-序列合并，产生候选k-序列。

- 候选**剪枝**
  - 一个候选 $k$-序列被剪枝，如果它的 $(k-1)$-序列最少有一个是非频繁的。
  - 例如，假设 $<\{1\} \{2\} \{3\} \{4\}>$ 是一个候选 4-序列。我们需要检查 $<\{1\} \{2\} \{4\}>$ 和 $<\{1\} \{3\} \{4\}>$ 是否是频繁 3-序列。由于它们都不是频繁的，因此可以删除候选 $<\{1\} \{2\} \{3\} \{4\}>$。
- 支持度计数
  - 在支持度计数期间，算法将枚举属于一个特定数据序列的所有候选 $k$-序列。
  - 计数之后，算法将识别出频繁 $k$-序列，并可以丢弃其支持度计数小于最小支持度阈值 $minsup$ 的候选。

- 例子：
  - $<\{1\} \{2\} \{3\} \{4\}>$ 是通过合并 $<\{1\} \{2\} \{3\}>$ 和 $<\{2\} \{3\} \{4\}>$ 得到。由于事件 3 和事件 4 属于第二个序列的不同元素，它们在合并后序列中也属于不同的元素。
  - $<\{1\} \{5\} \{3,4\}>$ 是通过合并 $<\{1\} \{5\} \{3\}>$ 和 $<\{5\} \{3,4\}>$ 得到。由于事件 3 和事件 4 属于第二个序列的相同元素，4 被合并到第一个序列的最后一个元素中。

**候选生成：GSP算法**

当且仅当通过**丢弃s1中的第一项**获得的子序列与通过**丢弃s2中的最后一项**而获得的子序列相同时，序列s1与另一序列s2合并。

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601161146.png" style="zoom:60%;" />

**序列合并过程**

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601161821.png" style="zoom: 33%;" />

例子：

<img src="https://raw.githubusercontent.com/abecedarian007/picgo_images/master/img/20240601161250.png" style="zoom: 40%;" />

### 候选序列生成的例子

考虑以下频繁3-序列：$<\{1,2,3\}>, <\{1,2\}\{3\}>, <\{1\}\{2,3\}>, <\{1,2\}\{4\}>, <\{1,3\}\{4\}>, <\{2,3\}\{3\}>, <\{2,3\}\{4\}>, <\{2\}\{3\}\{3\}>, <\{2\}\{3\}\{4\}>$

1. 列举出候选生成步骤产生的所有候选4-序列
   所有候选4-序列举如下：
   $<\{1,2,3\}\{3\}>, <\{1,2,3\}\{4\}>, <\{1,2\}\{3\}\{3\}>, <\{1,2\}\{3\}\{4\}>, <\{1,2,3\}\{4\}>$

2. 列出候选剪枝步骤剪掉的所有候选4-序列（假定没有时间限制）。如果没有时间限制，则所有候选子序列都必须频繁。因此，经过修剪剪掉的候选子序列（非频繁）为：
   $<\{1,2,3\}\{3\}>, <\{1,2\}\{3\}\{3\}>, <\{1,2,3\}\{4\}>$
   

剪枝后的候选序列为：$<\{1,2,3\}\{4\}>$
