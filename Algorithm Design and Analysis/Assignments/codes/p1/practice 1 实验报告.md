# practice 1 实验报告

## 1

### 1. 实验题目

在给定的由n个整数构成的集合S和另一个整数x的情况下，编写一个时间复杂度为$O(nlogn)$的算法，判断集合S中是否存在两个元素其和等于x。

### 2. 实验目的

- 掌握利用排序和双指针技术解决问题的方法。
- 理解时间复杂度对算法性能的影响。

### 3. 实验设计与分析

本实验通过对输入的整数集合S进行排序，然后使用两个指针（一个在数组开始，另一个在数组末尾）进行遍历，以检查是否存在两个其和等于x的元素。

- **算法设计**：首先对集合S进行排序，这一步的时间复杂度为$O(nlogn)$。排序后，使用两个指针left和right分别指向排序后数组的开始和结束位置。通过循环，不断地将left指向的元素和right指向的元素之和与x进行比较：
  - 如果和等于x，则找到了这样的一对元素，算法返回true。
  - 如果和小于x，则将left指针向右移动一位（即增加和的值）。
  - 如果和大于x，则将right指针向左移动一位（即减少和的值）。
  - 如果left和right指针相遇，则说明不存在这样的两个元素，算法返回false。
- **分析**：排序是算法中时间复杂度最高的步骤，为$O(nlogn)$。在排序之后，通过双指针的方法寻找符合条件的元素对的过程的时间复杂度为$O(n)$。因此，整个算法的时间复杂度主要由排序这一步骤决定，为$O(nlogn)$。

### 4. 实验环境

- 语言：C++
- 编译环境：GCC 8.1.0
- 操作系统：Windows 11
- 集成开发环境（IDE）：CLion

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 测试用例1：S = {1, 4, 45, 6, 10, -8}, x = 16。预期输出：“exist”，因为元素6和10的和等于16。
  - 测试用例2：S = {1, 2, 3, 4, 5}, x = 10。预期输出：“not exist”，因为没有任何两个元素的和等于10。
- **性能测试**：
  - 对不同规模的$n$进行测试，以验证算法的时间复杂度。随着$n$的增加，预期看到算法执行时间的增长趋势与$nlogn$相符。

## 2

### 1. 实验题目

实现优先队列（Priority Queue）。

### 2. 实验目的

- 学习优先队列的基本实现方法。
- 掌握二叉堆（Binary Heap）数据结构的操作，包括插入（shift up）和删除（shift down）操作。
- 理解优先队列在数据结构中的应用。

### 3. 实验设计与分析

本实验通过实现一个最大优先队列（Max Priority Queue），使用一个动态数组`std::vector<int>`来存储元素，以二叉堆的形式进行组织，其中父节点的值总是大于或等于其子节点的值。

- **数据结构**：选择使用二叉堆作为优先队列的内部表示，因为它能够有效地支持所需的操作。二叉堆可以通过一个数组实现，其中每个元素都保证大于等于其子节点的值（最大堆）。
- **主要操作**：
  - **push(val)**：将新元素插入到堆中，并通过`siftUp`操作维持堆的性质。这一操作确保了新插入的元素能够上移至正确的位置以保持最大堆的性质。
  - **pop()**：移除并返回堆顶元素（最大元素），通过将堆的最后一个元素移动到堆顶，然后执行`siftDown`操作来重新构造最大堆。
  - **top()**：返回堆顶元素，即最大元素，而不移除它。
  - **empty()**：检查优先队列是否为空。
- **辅助函数**：
  - **siftUp**和**siftDown**函数用于调整堆，以保持其最大堆性质。
  - **parent**，**leftChild**，和**rightChild**函数用于计算给定索引的父节点和子节点的索引。

### 4. 实验环境

- 语言：C++
- 编译环境：GCC 8.1.0
- 操作系统：Windows 11
- 集成开发环境（IDE）：CLion

### 5. 项目测试（功能与性能）

- **功能测试**：通过向优先队列中插入一系列元素，然后逐一移除它们并输出，以测试优先队列的正确性。预期输出应该是按照从大到小的顺序排列的元素。
  - 测试序列：{3, 1, 4, 1, 5, 9, 2, 6}。
  - 预期输出：9 6 5 4 3 2 1 1。
- **性能测试**：
  - **插入操作**（push）：每次插入操作的平均时间复杂度为$O(logn)$，其中n是堆中元素的数量。
  - **移除操作**（pop）：移除堆顶元素的时间复杂度为$O(logn)$，因为`siftDown`操作最多需要进行至堆的深度次比较和交换。

## 3

### 1. 实验题目

实现快速排序算法（QuickSort）。

### 2. 实验目的

- 理解和掌握快速排序算法的原理和实现方法。
- 学习如何通过随机化选择枢轴（pivot）来优化快速排序算法的平均性能。
- 分析快速排序算法的时间复杂度及其在不同情况下的表现。

### 3. 实验设计与分析

本实验通过实现一个快速排序算法来对数组进行排序。快速排序是一种高效的排序算法，采用分而治之的策略来对一个数组进行排序。

- **算法原理**：选择一个枢轴值，将数组分为两部分，使得左边的元素都不大于枢轴值，右边的元素都不小于枢轴值，然后对这两部分分别进行快速排序。
- **实现步骤**：
  1. **randomizePivot**：随机选择枢轴值，以改善算法的平均性能，避免在最坏情况下的性能退化。
  2. **partition**：对数组进行划分，返回枢轴的最终位置。此函数是快速排序的核心，确保枢轴左侧的元素不大于枢轴，枢轴右侧的元素不小于枢轴。
  3. **quickSort**：递归地对枢轴左右两侧的子数组进行快速排序，直到子数组的大小为1或0，此时数组已经排好序。
- **算法优化**：通过随机化枢轴选择来优化快速排序，这样可以减少算法对输入数据顺序的敏感性，从而在平均情况下提高性能。

### 4. 实验环境

- 语言：C++
- 编译环境：GCC 8.1.0
- 操作系统：Windows 11
- 集成开发环境（IDE）：CLion

### 5. 项目测试（功能与性能）

- **功能测试**：通过对特定的数组进行排序，测试快速排序算法的正确性。
  - 测试数组：{10, 7, 8, 9, 1, 5}。
  - 预期输出：1 5 7 8 9 10。
- **性能测试**：
  - **时间复杂度**：最好情况下为$O(nlogn)$，平均情况下为$O(nlogn)$，最坏情况下为$O(n^2)$。通过随机化枢轴的选择，可以有效地将平均性能保持在接近最好情况的水平。
  - 对不同大小的数组进行排序，观察算法的执行时间，验证算法的时间复杂度。

### 6. 问题回答

#### (1) 在所有元素值都相同的n个元素列表上，Quicksort将进行多少次比较？

当所有元素的值都相同时，Quicksort的性能取决于其分区策略。在最坏的情况下，如果算法每次都选择第一个或最后一个元素作为枢轴，并且不对分区过程进行优化以处理所有相等的元素，那么每次分区只能将数组分成两部分：一个为空（或仅包含枢轴元素），另一个包含剩余的所有元素。这会导致递归深度为n，每一层递归都会对n-1, n-2, ..., 1的元素进行比较。因此，比较的总次数将近似为$n + (n-1) + (n-2) + ... + 1 = \frac{n(n+1)}{2} - 1$，大约为$O(n^2)$。

#### (2) Quicksort在n个元素的列表上的比较次数的最大值和最小值是多少？分别给出最大和最小情况的实例。

- **最小比较次数**：Quicksort的最佳情况发生在每次分区都能将列表平均分成两半时。这样，递归的深度是$log(n)$，每一层的比较总数大约为n，所以总的比较次数大约为$n \cdot log(n)$。最小比较次数的实例是，每次选取的枢轴都能精确地将数组分成长度几乎相等的两部分。

- **最大比较次数**：最坏的情况发生在每次分区操作之后，一个子数组包含n-1个元素，而另一个子数组为空（或仅包含枢轴元素）。这通常发生在数组已经排序或逆序，并且每次都选择第一个或最后一个元素作为枢轴。在这种情况下，比较次数为$n + (n-1) + (n-2) + ... + 1 = \frac{n(n+1)}{2} - 1$，大约为 $O(n^2)$。最大比较次数的实例是完全排序或完全逆序的数组，且每次分区选择的枢轴是当前子数组中的最小或最大元素。

## 4

### 1. 实验题目

使用分治算法在两个已排序数组中找到第k大的元素。

### 2. 实验目的

- 掌握分治算法的设计思想和应用。
- 学习如何在两个排序数组中有效地查找第k大的元素。
- 分析算法的时间复杂度，了解如何通过减少问题规模来优化性能。

### 3. 实验设计与分析

本实验通过一个分治算法解决了在两个已排序数组中查找第k大元素的问题。

#### 算法设计

- 确保总是在两个数组中较短的一个进行分割，以最小化递归深度。
- 当一个数组为空时，直接从另一个数组中返回第k大的元素。
- 当k减少到1时，返回两个数组中当前考虑的首元素的较小者。
- 通过比较两个数组中的第k/2个元素，排除较小的那部分元素，从而减少k的值并递归求解。

为了优化性能，算法设计中引入了以下关键策略：

1. **较短数组的优先处理**：通过始终在较短的数组中进行分割操作，减少递归调用的次数，从而减小总体的时间复杂度。
2. **递归基条件的优化**：当遇到特定条件（如一个数组为空，或k缩减至1）时，直接计算结果而不进一步递归，从而避免不必要的计算。
3. **动态调整k值和索引**：通过动态调整k值和递归函数的索引参数，每次递归调用都精确排除掉不可能是第k大元素的数组部分。

#### 实验分析

- **算法复杂度**：本算法的时间复杂度为$O(log m + log n)$，其中$m$和$n$分别代表两个数组的长度。这得益于每次递归都能至少排除$k/2$个元素，从而将问题规模减半。与直接合并两数组后排序或线性扫描相比，此方法大大提高了效率。
- **空间复杂度**：算法的空间复杂度主要由递归调用栈的深度决定，为$O(log m + log n)$。与时间复杂度相同，这也是因为每次递归都会减少问题的规模。
- **算法优势**：相较于非分治法的解法，如直接合并两个数组后查找第k大元素，本算法无需额外$O(m+n)$的空间，也不需要$O((m+n)log(m+n))$的时间复杂度进行排序。因此，它在处理大数据集时具有明显的性能优势。

### 4. 实验环境

- 语言：C++
- 编译环境：GCC 8.1.0
- 操作系统：Windows 11
- 集成开发环境（IDE）：CLion

### 5. 项目测试（功能与性能）

- **功能测试**：通过在不同的两个已排序数组和不同的k值上运行算法，验证其正确性。
  - 测试案例1：nums1 = {1, 3, 5, 7, 10}，nums2 = {2, 4, 6, 8, 9}，k = 1。预期结果：第1大的元素是10。
  - 测试案例2：同上，但k = 3。预期结果：第3大的元素是8。
- **性能测试**：
  - 本算法的时间复杂度为$O(log m + log n)$，其中m和n分别是两个数组的长度。通过在具有不同大小（m和n）的数组上运行算法，并记录执行时间，可以验证这一时间复杂度。
  - 性能测试应该展示出，随着m和n的增加，算法的执行时间的增长率应该接近对数增长，这验证了其高效性。