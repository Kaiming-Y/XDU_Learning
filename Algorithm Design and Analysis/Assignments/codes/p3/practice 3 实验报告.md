# practice 3 实验报告

## 1

### 1. 实验题目

实现分数背包和0/1背包问题的求解。

### 2. 实验目的

- 掌握分数背包和0/1背包问题的解决策略。
- 理解和应用贪心算法与动态规划算法。
- 分析并比较两种算法在解决背包问题时的性能和适用性。

### 3. 实验设计与分析

- 本实验通过贪心算法解决分数背包问题，并通过动态规划解决0/1背包问题。

  #### 算法设计

  - 分数背包问题：
    - 使用贪心算法，根据价值/重量比降序排序物品。
    - 优先选择价值/重量比高的物品，如果当前物品可以完全装入背包，则加入；否则按比例加入。
  - 0/1背包问题：
    - 使用动态规划，构建一个二维DP表格。
    - 表格的行代表考虑的物品数，列代表背包的容量。
    - 填充表格，使得每个单元格的值代表在当前背包容量和可选物品下能达到的最大价值。

  #### 实验分析

  - 时间复杂度：
    - 分数背包问题的算法时间复杂度主要由排序决定，为$O(n \log n)$。
    - 0/1背包问题的动态规划算法时间复杂度为$O(nW)$，其中$W$是背包的最大容量。
  - 空间复杂度：
    - 分数背包问题的空间复杂度为$O(1)$（不考虑输入存储）。
    - 0/1背包问题的空间复杂度为$O(nW)$，由于DP表的大小决定。
  - 算法优势：
    - 分数背包的贪心算法在物品可以分割的情况下非常有效，但不适用于物品不可分割的情况。
    - 0/1背包的动态规划算法虽然时间和空间复杂度较高，但能确保找到最优解。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- 功能测试：
  - 测试了在给定的五个物品和不同背包容量限制下算法的正确性。
  - 测试案例：物品价值和重量对为`[(20, 10), (30, 20), (65, 30), (40, 40), (60, 50)]`，背包最大重量为80磅。
  - 预期结果：分数背包应得到最大价值，0/1背包也应得到一个最优解。
- 性能测试：
  - 通过改变物品的数量和背包的容量，测试算法在不同情况下的表现。
  - 性能测试结果应显示，动态规划的执行时间随物品数量和背包容量线性增长，贪心算法的执行时间主要由排序决定。

## 2

### 1. 实验题目

实现简单作业调度问题的求解。

### 2. 实验目的

- 掌握非抢占式单处理器作业调度算法。
- 学习如何最小化平均完成时间。
- 分析排序策略对作业调度性能的影响。

### 3. 实验设计与分析

本实验通过对作业的运行时间进行排序，以求得最小平均完成时间的作业调度。

- **算法设计**：

  - 作业调度策略：
    - 对作业按运行时间升序排序，目的是尽快完成运行时间短的作业，从而减少后续作业的等待时间。
    - 计算每个作业的完成时间，随后求得平均完成时间。

  为了优化作业调度，算法设计中采用了以下关键策略：

  1. **作业优先排序**：通过对作业按运行时间进行升序排序，确保总的等待时间最小化。
  2. **累积完成时间计算**：通过累积前一个作业的完成时间来计算当前作业的完成时间，从而计算出整个作业调度的平均完成时间。

- **实验分析**：

  - **算法复杂度**：本算法的时间复杂度主要由排序决定，为$O(n \log n)$，其中$n$是作业的数量。
  - **空间复杂度**：算法的空间复杂度为$O(n)$，主要用于存储作业的排序和完成时间。
  - **算法优势**：简单且有效，特别适合于作业可以按照确定的时间排序执行的场景。


### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- 功能测试：
  - 测试在给定的四个作业和已知运行时间上算法的正确性。
  - 测试案例：作业运行时间为`[15, 8, 3, 10]`。
  - 预期结果：最优作业调度顺序应当为`[3, 8, 10, 15]`，以实现最小的平均完成时间。
- 性能测试：
  - 通过改变作业的数量和运行时间，测试算法在不同情况下的表现。
  - 性能测试结果应显示，算法的执行时间主要由作业数量决定的排序操作所支配。

## 3

### 1. 实验题目

实现单源最短路径算法。

### 2. 实验目的

- 掌握如何通过Bellman-Ford算法和Dijkstra算法解决单源最短路径问题。
- 分析并比较两种算法在有向图中的适用性和效率。
- 学习处理带有负权边的图的算法设计。

### 3. 实验设计与分析

本实验通过Bellman-Ford算法和Dijkstra算法求解单源最短路径问题，同时处理负权边。

- **算法设计**：
  - Bellman-Ford算法：
    - 遍历所有边$|V|-1$次，其中$|V|$是顶点数。每次遍历尝试通过每个顶点更新所有可达顶点的最短路径估计。
    - 检测图中是否存在负权重循环，若存在则报告并终止算法。
  - Dijkstra算法：
    - 使用优先队列（最小堆）来持续追踪当前找到的最短路径未定顶点。
    - 更新距离表来记录从源点到每个顶点的最短距离。
    - Dijkstra算法不适用于包含负权边的图。
- **算法分析**：
  - 时间复杂度：
    - Bellman-Ford算法的时间复杂度为$O(VE)$，适用于含有负权边的图。
    - Dijkstra算法的时间复杂度可以通过二叉堆优化至$O((V+E)\log V)$，适用于不含负权边的图。

  - 空间复杂度：
    - Bellman-Ford算法的空间复杂度为$O(V)$。
    - Dijkstra算法同样具有$O(V)$的空间复杂度。

  - 算法优势与局限：
    - Bellman-Ford算法可以处理负权边，但是较慢。
    - Dijkstra算法更快但不能处理负权边。


### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- 功能测试：
  - 测试在给定的图和源点A上算法的正确性。
  - 测试案例：采用题目给出的邻接矩阵。
  - 预期结果：Bellman-Ford应该能够识别负权环，Dijkstra应提供未考虑负权边情况下的最短路径。
- 性能测试：
  - 通过改变图的规模和复杂性，测试两种算法在不同情况下的表现。
  - 性能测试结果应显示Bellman-Ford的执行时间随图的顶点和边的数量线性增长，而Dijkstra算法的执行时间随着图的稠密程度和顶点数的增加呈对数增长。

## 4

### 1. 实验题目

实现全源最短路径算法。

### 2. 实验目的

- 掌握如何通过Floyd-Warshall算法求解全源最短路径问题。
- 分析算法在处理负权边图中的表现和应用。
- 学习多阶段动态规划在图论中的应用。

### 3. 实验设计与分析

本实验通过Floyd-Warshall算法解决了全源最短路径问题，即计算图中所有顶点对之间的最短路径。

- **算法设计**：
  - 初始化距离矩阵，其中对角线元素为0，其他元素为两点间边的权重（若无边则为无穷大）。
  - 通过三重循环更新距离矩阵，每次迭代考虑通过一个中间顶点`k`是否可以缩短顶点`i`到顶点`j`的距离。
  - 算法结束时，距离矩阵的每个元素`distance[i][j]`表示从顶点`i`到顶点`j`的最短路径长度。
- **算法分析**：
  - 时间复杂度：
    - Floyd-Warshall算法的时间复杂度为$O(n^3)$，其中$n$是顶点的数量。
  - 空间复杂度：
    - 空间复杂度为$O(n^2)$，由于需要存储每对顶点之间的最短路径长度。
  - 算法优势与局限：
    - Floyd-Warshall算法能处理包括负权边在内的任何权重，且能计算所有顶点对的最短路径。
    - 时间和空间复杂度较高，不适合用于大规模图。


### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- 功能测试：
  - 测试算法在给定邻接矩阵上的正确性。
  - 测试案例：使用题目中提供的邻接矩阵。
  - 预期结果：算法应正确计算出所有顶点对之间的最短路径长度。
- 性能测试：
  - 通过增加顶点数量和边的复杂性，测试算法在不同规模的图上的表现。
  - 性能测试结果应显示，算法的执行时间随图的顶点数的增加而呈立方增长。

