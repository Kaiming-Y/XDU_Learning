# practice 2 实验报告

## 1

### 1. 实验题目

**矩阵链乘积**问题。给定一系列矩阵的维度，计算完全括号化乘积（即，决定矩阵乘积的计算顺序）使得所需的标量乘法次数最少。

### 2. 实验目的

- 掌握动态规划解决矩阵链乘积问题的方法。
- 理解如何通过优化计算顺序来减少计算成本。
- 学习如何使用多维数组在Python中存储动态规划的中间结果。

### 3. 实验设计与分析

本实验使用动态规划解决矩阵链乘积问题。通过计算和比较所有可能的括号化方案，找到乘法操作次数最少的方案。

- **算法设计**：

  - 初始化一个二维数组`m`来存储计算某个矩阵链从`i`到`j`的最小乘法次数。
  - 外层循环`chain_len`从2开始，逐步增加处理的链长度。
  - 内层循环用于遍历所有可能的开始点`begin`和结束点`end`。
  - 对于每一对`begin`和`end`，通过遍历所有可能的分割点`k`来计算最小乘法次数。
  - 每次分割都会计算两部分矩阵链以及它们之间的乘积所需的乘法次数，然后更新 `m[begin][end]`。

- **分析**：

  这个算法利用了动态规划的优点，避免了重复计算相同的子问题，大大降低了计算成本。整个算法的时间复杂度为$O(n^3)$，其中$n$是矩阵链的长度。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 实例a)：<3, 5, 2, 1, 10>，预期最少乘法次数：90。
  - 实例b)：<2, 7, 3, 6, 10>，预期最少乘法次数：158。
  - 实例c)：<10, 3, 15, 12, 7, 2>，预期最少乘法次数：348。
  - 实例d)：<7, 2, 4, 15, 20, 5>，预期最少乘法次数：250。
- **性能测试**：
  - 对不同长度的矩阵链进行测试，验证算法的时间复杂度。由于时间复杂度为$O(n^3)$，所以随着矩阵链长度的增加，算法的运行时间会按立方的速率增长。

## 2

### 1. 实验题目

**最长公共子序列（LCS）**问题。给定两个序列，找出它们之间的最长公共子序列的长度。

### 2. 实验目的

- 掌握动态规划解决最长公共子序列问题的策略。
- 学习如何构建和解读动态规划表格。
- 理解子问题划分和最优子结构的概念。

### 3. 实验设计与分析

本实验使用动态规划算法解决最长公共子序列问题。通过构建一个二维数组`dp`来记录两个序列前`i`和`j`个字符的最长公共子序列的长度。

- **算法设计**：

  - 初始化一个`(x_len+1) x (y_len+1)`的二维数组`dp`，其中`x_len`和`y_len`分别为两个序列的长度。
  - 遍历序列X和Y，使用嵌套循环比较序列中的每个字符。
  - 当发现相同的字符时，`dp[i][j]`被更新为`dp[i-1][j-1] + 1`，意味着找到了一个公共字符，并在之前找到的最长子序列的基础上增加长度。
  - 当字符不匹配时，`dp[i][j]`更新为`dp[i-1][j]`和`dp[i][j-1]`中的较大值，反映了取较长的已知子序列。

- **分析**：

  通过动态规划，避免了重复计算，确保了算法的高效性。整个算法的时间复杂度为$O(nm)$，其中$n$和$m$分别是输入序列的长度。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 实例a)：X: "xzyzzyx"，Y: "zxyyzxz"。预期最长公共子序列长度：5。
  - 实例b)：X: “MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD”, Y:”MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG” 。预期最长公共子序列长度：83。
- **性能测试**：
  - 对不同长度的序列对进行测试，验证算法的时间复杂度。实验结果显示，随着序列长度的增加，所需计算时间增长与序列长度的乘积大致成正比，符合算法设计的时间复杂度$O(nm)$。

## 3

### 1. 实验题目

求最长公共子串。给定两个序列，找出它们之间的最长公共子串的长度。

### 2. 实验目的

- 掌握动态规划解决最长公共子串问题的方法。
- 学习如何利用二维数组记录子问题的解。
- 理解最长公共子串与最长公共子序列问题的区别。

### 3. 实验设计与分析

**最长公共子串**问题。与最长公共子序列（LCS）问题不同，最长公共子串要求序列中的字符必须连续。

- **算法设计**：
  - 初始化一个`(x_len+1) x (y_len+1)`的二维数组`dp`，用于存储以`x[i-1]`和`y[j-1]`结尾的最长公共子串的长度。
  - 遍历序列X和Y，当`x[i-1]`等于`y[j-1]`时，`dp[i][j] = dp[i-1][j-1] + 1`。这表示当前字符匹配并且可以扩展前一个匹配的子串。
  - 如果字符不匹配，`dp[i][j]`设为0，表示以`x[i-1]`和`y[j-1]`结尾的子串不可能是公共子串。
  - 使用一个变量`max_len`记录遍历过程中遇到的最长公共子串的长度。
- **分析**：这个算法高效地找出了两个序列之间的最长公共子串。由于只需处理序列一次，且每次比较操作为常数时间，整个算法的时间复杂度为$O(nm)$，其中$n$和$m$分别是输入序列的长度。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 实例a)：X: "xzyzzyx"，Y: "zxyyzxz"。预期最长公共子串长度：3。
  - 实例b)：X: “MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCALLAAQANKESSSESFISRLLAIVAD”, Y:”MAEEEVAKLEKHLMLLRQEYVKLQKKLAETEKRCTLLAAQANKENSNESFISRLLAIVAG” 。预期最长公共子串长度：22。
- **性能测试**：
  - 对不同长度的序列对进行测试，以评估算法处理大规模数据的能力。实验结果表明，算法的执行时间随输入序列长度的增加而线性增长，与算法的时间复杂度预期相符。

## 4

### 1. 实验题目

**最大子数组和**问题。给定一个整数数组，找出具有最大和的连续子数组（至少包含一个数），返回其最大和。

### 2. 实验目的

- 掌握动态规划解决最大子数组和问题的方法。
- 学习如何通过局部最优解推导全局最优解。
- 理解动态规划与分治策略在解决问题时的不同之处。

### 3. 实验设计与分析

本实验采用动态规划的思路解决最大子数组和问题。动态规划方法旨在通过维护一个数组`dp`来记录到当前位置为止的最大子数组和，从而找到全局最大子数组和。

- **算法设计**：
  - 初始化`dp`数组，`dp[i]`表示以`array[i]`结尾的最大子序列和。
  - `dp[0]`初始化为`array[0]`，即第一个元素自成一组时的最大子序列和。
  - 遍历数组`array`，对于每个`array[i]`，比较`dp[i-1] + array[i]`与`array[i]`的大小。如果`dp[i-1]`为负，则`dp[i]`应为`array[i]`，否则，`dp[i]`更新为`dp[i-1] + array[i]`。
  - 最终结果为`dp`数组中的最大值，即所有以`array[i]`结尾的子数组和中的最大值。
- **分析**：通过动态规划，算法避免了对于每个子数组和的重复计算，将问题简化为了局部最优解的比较和选择。整个算法的时间复杂度为$O(n)$，其中$n$是数组的长度。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 实例：数组(-2, 11, -4, 13, -5, -2)。预期最大子数组和为20，由子数组(11, -4, 13)得到。
- **性能测试**：
  - 对不同长度的数组进行测试，以评估算法处理大规模数据的能力。实验结果表明，无论数组大小如何，算法都能在线性时间内完成计算，证明了其高效性。

## 5

### 1. 实验题目

**多阶段图中的最短路径**问题。对于给定的多阶段图，找出从节点0到节点15的最短路径。

### 2. 实验目的

- 掌握如何应用Dijkstra算法解决加权图的单源最短路径问题。
- 学习如何通过优先级队列优化Dijkstra算法。
- 理解多阶段图的特性及其在路径规划中的应用。

### 3. 实验设计与分析

本实验使用Dijkstra算法找出多阶段图中从起点到终点的最短路径。多阶段图的特性是节点被分为不同的级别，且边只从某个级别指向下一个级别。

- **算法设计**：
  - 采用Dijkstra算法，并使用两个字典来分别记录每个节点的最短路径长度和前驱节点。
  - 初始化时，起点的距离设为0，其余所有节点的距离设为无穷大。
  - 使用一个集合来记录已访问过的节点，确保不会重复处理节点。
  - 循环中，选择当前未访问过且距离最小的节点作为当前节点，更新其邻居节点的距离和前驱节点。
  - 使用辅助函数`get_min_distance_node`来选取未访问节点中距离最短的节点。
- **分析**：在多阶段图中使用Dijkstra算法，由于边的特殊性质，算法保持了高效性。在本实验中，算法的时间复杂度为$O(V^2)$，但可以通过优先级队列优化到$O(VlogV)$。

### 4. 实验环境

- 语言：Python
- 解释器：Python 3.8
- 操作系统：Windows 11
- 集成开发环境（IDE）：PyCharm

### 5. 项目测试（功能与性能）

- **功能测试**：
  - 对图中的节点0到15计算最短路径。预期输出：最短路径序列和路径长度。
- **性能测试**：
  - 在图中加入更多节点和边，评估算法的扩展性。预期随着图的规模增加，算法运行时间的增长应与节点数量的平方成正比。若使用优先级队列可以预期更好的性能。