# 01 软件体系结构定义

<u>**软件体系结构** **=** **组件** **+** **连接件** **+** **约束**</u>

- **组件：**具有某种功能的可重用的**软件模块单元**，表示了系统中主要的**计算单元**和**数据存储**。

- **连接件：**。
  - 简单的连接件有：管道（pipe）、过程调用（procedure-call）、事件广播（event broadcast）等。
  - 复杂的连接件有：客户－服务器（client-server）通信协议，数据库和应用之间SQL连接等。

- **约束：**表示了组件和连接件的**拓扑逻辑**和**约束**（constraint）。







# 02 软件体系结构风格

软件体系结构风格：描述特定领域中软件系统家族的**组织方式的惯用模式**(idiomatic paradigm)，反映了领域中众多系统所共有的**结构和语义特性**，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

**<u>软件体系结构风格 = 组件/连接件集 + 拓扑 + 约束</u>**

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610145218.png" style="zoom:67%;" />




## I. 数据流风格 Data Flow

> 1. **特征**：
>
>   - 数据的可用性决定着计算单元是否执行
>
>   - 系统结构由数据在各处理之间的有序移动决定
>
>   - 在纯数据流系统中，处理之间除了数据交换没有任何其他的交互
>
> 2. **定义**：
>
>   - **组件**：数据处理
>
>     <img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610151701.png" style="zoom:50%;" />
>
>   - **连接件**：数据流
>
>     <img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610151732.png" style="zoom:50%;" />
>
> 3. 补充：<u>数据不是自由流动的</u>
>    - 近似线性数据流
>    - 在限度内的循环数据流



### i. 批处理风格 Batch Sequential

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610150928.png" style="zoom:67%;" />

#### 定义

- **组件**：独立的应用程序
- **连接件**：某种类型的媒质
- **拓扑**：连接件定义了相应的数据流图，表达拓扑结构
- **约束**：
  - 每个处理步骤是一个**独立的程序**；
  - 每一步必须在**前一步结束后**才能开始；
  - **数据必须是完整的**，以**整体**的方式传递。

#### 适用场景

大量整体数据传输时适用

#### 优缺点

- 优点
  - 无需考虑同步问题
  - 可以随机存取数据
- 缺点
  - 计算效率低，无法并行计算
  - 无法实时计算
  - 交互性差

#### 应用实例

*Eclipse重复代码检测工具、传统编译器*



### ii. 管道-过滤器风格 Pipes and Filters

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610154435.png" style="zoom:50%;" />

#### 定义

- **组件**：过滤器 —— 处理数据流
  - 目标：将原数据变换成目标数据

  - 从 “数据流” → “数据流” 的变换
  - 过滤器对数据流的五种变换类型
    - 增加/丰富：通过计算和增加信息来丰富数据
    - 删减/浓缩：通过浓缩和删减来精炼数据
    - 转换：通过改变数据表现方式来转化数据
    - 分解：将一个数据流分解为多个数据
    - 合并：将多个数据流合并为一个数据流

- **连接件**：管道 —— 连接一个源和一个目的过滤器
  - 递增的读取和消费数据流：即在输入被完全消费之前，输出便产生了
  - 单向流
  - 可能有缓冲区
  - 管道形成传输图
  
- **拓扑**：连接件定义数据流图

- **约束**：过滤器是相互独立的
  - 无上下文信息
  - 不保留状态
  - 对其他过滤器无任何了解

#### 适用场景

数据源源不断的产生，系统需要对这些数据进行若干处理

#### 优缺点

- 优点

  - 具有隐蔽性和高内聚、低耦合的特点

  - 支持软件复用

  - 系统容易维护和拓展
  - 允许对一些属性分析
  - 支持并行执行
- 缺点
  - 不适合处理交互的应用
  - 系统性能不高

#### 应用实例

*编译器、Unix管道、图像处理、信号处理*



### 批处理 *vs*  管道-过滤器

|      批处理      | 管道-过滤器  |
| :--------------: | :----------: |
|   整体传递数据   |     增量     |
|   构建粒度较大   | 构建粒度较小 |
| 延迟高，实时性差 |   实时性好   |
|      无并发      |    可并发    |





## II. 调用-返回风格 Call/Return



### i. 主程序/子程序风格 Main Program and Subroutines

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610172031.png" style="zoom:50%;" />

#### 定义

- **组件**：过程和显式可见数据
- **连接件**：过程调用和显式数据共享
- **约束**：适合计算可被结构化定义的应用
- **系统模型**：调用和定义层次结构，子系统通常通过模块化来定义
- **控制结构**：单线程

#### 适用场景

适用于计算过程可被定义为结构化过程的应用

#### 优缺点

- 优点
  - 逐步分解问题，划分为若干处理步骤
  - 单线程控制
- 缺点
  - 只适用于可以定义为一系列步骤的问题
  - 子系统结构不清晰



### ii. 面向对象风格 Object Oriented

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610174113.png" style="zoom:50%;" />

#### 定义

- **组件**：管理者（servers，objects，ADT）
- **连接件**：过程调用
- **系统模型**：本地状态维护
- **控制结构**：分散式，通常为单线程

#### 适用场景

适用于核心问题是识别和保护相关对象的信息（特别是表示信息）的应用程序

#### 优缺点

- 优点
  - 易于复用和维护
  - 反映现实世界
  - 易于分解一个系统
  - 对象抽象使得组件和组件之间的操作以黑箱的方式进行
  - 封装使得细节内容对外部环境得以良好的隐藏，安全性强
- 缺点
  - 对象的管理比较复杂，耦合度较紧
  - 对象过多时需要额外的结构来容纳、维护，复杂性提高
  - 继承会使系统逻辑变得更加复杂
  - 单一的接口能力有限并且笨拙

#### 面向对象体系结构的元素

- **封装（Encapsulation）**：限制对某些信息的访问
- **交互（Interaction）**：通过过程调用或类似的协议
- **继承（Inheritance）**：对共享的功能保持唯一的接口
- **复用和维护（Reuse and maintenance）**：利用封装和聚合提高生产力

#### 抽象数据类型 ADT

操作和数据绑定在一起，隐藏实现和其他秘密



### iii. 层次风格 Layered

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610203520.png"  />

#### 定义

- **组件**：通常是复合体，过程的集合
- **连接件**：取决于组件的结构，通常是严格受限的过程调用
- **系统模型**：不透明层的层次结构
- **控制结构**：单线程

#### 适用场景

适用于不同服务类别可被分层管理的应用程序

#### 优缺点

- 优点

  - 每层为上一层提供服务，使用下一层的服务，只能访问相邻层

  - 大的问题分解为若干个渐进的小问题，逐步解决，隐藏了很多复杂度

  - 修改一层，最多影响两层，而通常只能影响上层。接口稳固，则谁都不影响。

- 缺点
  - 上层必须知道下层的身份，不能调整层次之间的顺序。
  - 层层相调，影响性能。

#### 应用实例

*OSI七层模型，操作系统内核*



### iv. 客户端/服务器风格 Client/Server

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610205338.png" style="zoom:50%;" />

#### 两层C/S结构

- C/S软件体系结构是基于资源不对等

- C/S体系结构有三个主要组成部分：

  - 数据库服务器

  - 客户应用程序

  - 网络

- 服务器（后台）负责数据管理，客户机（前台）完成与用户的交互任务。
- 缺点
  - 对客户端软硬件配置要求较高
  - 客户端程序设计复杂
  - 数据安全性不好，客户端程序可以直接访问数据库服务器
  - 信息内容和形式单一
  - 用户界面风格不一
  - 软件维护与升级困难

#### 三层C/S结构

- 与二层C/S结构相比，增加了一个**应用服务器**：整个应用逻辑驻留在应用服务器上。
- 应用功能分为表示层、功能层、数据层三层
  - **表示层**是应用的用户接口部分，通常使用图形用户界面
  - **功能层**是应用的主体，实现具体的业务处理逻辑
  - **数据层**是数据库管理系统
  - 以上三层逻辑上独立，通常只有表示层配置在客户机中

#### B/S结构（浏览器/服务器结构）

- B/S体系结构是三层C/S体系结构的特例
- 优点
  - 客户端有http浏览器即可
  - 使用标准http/https协议，省却很多麻烦
- 缺点
  - 只能“拉”，不能“推”
  - 客户之间的通信只能通过服务器中转
  - B/S结构的安全性较难控制，例如SQL注入
  - B/S结构的应用系统在数据查询等相应速度上，要远远低于C/S体系结构
  - 服务器的负荷大，客户机的资源浪费





## III. 以数据为中心风格 Data Centered

> 定义：以数据为中心的风格架构涉及到信息传递的共享数据源方法



### i. 仓库风格 Repository

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610214333.png" style="zoom:50%;" />

#### 定义

<u>仓库是存储和维护数据的中心场所</u>

- **组件**：
  - **中心数据结构**，表示当前数据的状态
  - 一组对中心数据进行操作的**独立构件**
- **连接件**：仓库与独立构件之间的交互  
- **交互机制**：
  1. 数据库方式：输入流中的事务类型触发需要执行的过程
  2. 黑板结构：中心数据结构的当前状态触发并选择需要执行的过程  

#### 适用场景

适用于核心问题是为了创建、增强和维护一个复杂的中心信息体的应用

#### 优缺点

- 优点
  - 并行操作，高性能
  - 易于增加生产者和消费者
- 缺点
  - 内存共享数据的同步问题
  - ACID难以保持

#### 应用实例

*数据库、现代规范的编译器结构*



### ii. 黑板风格 Blackboard

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610215554.png" style="zoom:50%;" />

#### 定义

中心数据结构的当前状态触发并选择需要执行的过程

- **组件**：

  - 黑板
    - **全局数据库**，用来存储数据、传递信息，包含解域的全部状态
    - 解决问题过程中的**状态数据**，以**层次**组织起来
    - **知识源对黑板进行修改**，逐渐找到问题的解
    - 各知识源之间的**通讯和交互只通过黑板进行**
  - 知识源
    - 描述某个独立领域问题的知识及其处理方法的知识库。知识源之间**相互独立**，通过黑板进行通讯，合作求出问题的解。知识源具有**“条件-动作”**的形式，当条件满足时，知识源被触发，其动作部分增加或修改黑板上的内容
    - 待解决的问题被分为若干个子问题，每个**子问题**由一个独立的知识源加以计算
    - 知识源包含**独立的领域知识**
    - 知识源执行计算后会**更新黑板**的数据状态
    - 多个知识源之间只能**通过黑板交换知识**，通过对黑板的读写操作来完成交换

  - 控制器
    - 黑板模型求解问题的**推理机构**
    - 时刻监视黑板状态变化，对黑板上信息的当前状态进行判断和评价
    - 当黑板的状态满足了知识源的执行条件时，该知识源被控制器触发并进行计算，然后将结果更新到黑板上这种更新又导致其他知识源参与计算并更新黑板，直到找到问题解为止
    - 根据黑板的状态变化**激活相关知识源**，调度程序**选择最合适的知识源**来执行，用执行结果**修改黑板状态**
    - 用来控制和协调**所有的知识源**，使其**协同的解决问题**
    - 了解各个知识源的能力，**实时决策解决问题的步骤**

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240610220023.png" style="zoom:50%;" />

- **连接件**：调用、访问

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611124303.png" style="zoom:50%;" />

#### 适用场景

适用于没有直接的算法可解，答案是不确定的

#### 优缺点

- 优点
  - 知识源可复用
  - 可更改性和可维护性
  - 可用于非确定性问题的求解
  - 容错性和健壮性
- 缺点
  - 测试困难
  - 低效，计算开销大
  - 开发困难
  - 不能确保有好的解决方案
  - 问题解答的不确定性
  - 缺少并行机制

#### 应用实例

*人工智能领域：自然语言处理、语音处理、模式识别、图像处理*





## IV. 虚拟机风格 Virtual Machine



### i. 解释器风格 Interpreter

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611141639.png"/>

#### 定义

- **组件**：一个状态机（解释器引擎）、三个内存（执行引擎的当前状态、正在解释的程序、正在解释的程序的状态）
- **连接件**：数据访问和过程调用
- **系统模型**：虚拟机
- **控制结构**：执行引擎的状态转换；输入驱动以选择要解释的内容

#### 适用场景

适用于：

- 无法直接获得最合适的语言或机器来执行解决方案的应用程序
- 核心问题是定义用于表达解决方案的符号（例如脚本）的应用程序

#### 优缺点

- 优点
  - 功能性：可以模拟非本地原生支持的功能
  - 测试性：可以在模拟极端条件（disaster mode）监测系统
  - 灵活性：非常通用的工具
- 缺点
  - 低效：效率比硬件及编译好的系统低
  - 测试：额外软件层的正确性需要验证

#### 应用实例

解释型语言（Java字节码、Javascript、HTML、脚本、配置文件）；通信协议；用户输入（游戏中的组合按键）



### ii. 规则系统风格 Rule-based System

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611142844.png" style="zoom:67%;" />

#### 定义

把频繁变化的、复杂的业务规则抽取出来（形成规则库），与系统其他不易发生变化的部分进行分离

- **组件**：
  - 规则/知识库：需要执行的代码
  - 规则解释器：解释器引擎
  - 规则/数据选择：解释器的控制状态
  - 工作内存：代码的当前状态
- **连接件**：直接访问和过程调用

许多产品规则系统的大脑实际上就是一个推理引擎，用于匹配 **事实 (Fact)** 和 **规则 (Rule)**。当匹配被找到，规则对应的 **动作 (Action)** 会被 **触发 (Fire)**。

#### 适用场景

适用于业务逻辑复杂，业务规则经常改变的场景（不适合if-else）

#### 优缺点

- 优点
  - 降低了修改业务的逻辑成本
  - 缩短开发时间（运营人员可以写规则）
  - 规则可在多个应用/平台中共享

- 缺点
  - 规则设置可能会有冲突和遗漏，规则关系不透明
  - 规则匹配的性能问题
  - 没有学习能力

#### 应用实例

Drools



### 解释器风格 *vs* 规则系统风格

- 解释器：在高级程序语言与OS/硬件平台间建立虚拟机
- 基于规则的系统：在自然语言/XML规则和高级程序语言间建立虚拟机





## V. 独立组件风格 Independent Components



### i. 进程通信风格 Communicating Processes

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611152422.png" style="zoom: 67%;" />

#### 定义

- **组件**：收发消息的进程
- **连接件**：消息
- **控制结构**：每个都有一个线程控制

#### 适用场景

适用于涉及一系列不同且基本独立的计算的应用程序，这些计算的执行应独立进行

#### 优点

可多线程，性能高



### ii. 事件系统风格 - 隐式调用 Event System - Implicit Invocation

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611173549.png" style="zoom:50%;" />

#### 定义

在隐式调用式系统中，事件会隐式地导致调用其他模块中的过程。

- **组件**：对象或过程，其接口提供一组过程和一组事件
  - 事件源：一个组件可以广播一些事件
  - 事件处理器：系统中的其它构件可以注册自己感兴趣的事件，并将自己的某个过程与相应的事件进行关联
  - 事件管理器：当一个事件被发布，系统自动调用在该事件中注册的所有过程。

- **连接件**：事件-过程绑定

  - 过程<事件处理器>向特定的事件进行注册

  - 构件<事件源>发布事件
  - 当某些事件被发布时，向其注册的过程被隐式调用
  - 调用的次序是不确定的
  - 在某些情况下，一个事件也可能触发其他事件，形成事件链

#### 优缺点

- 优点
  - 为软件重用提供了强大的支持
  - 为改进系统带来了方便
  - 性能高：便于并行操作
  - 健壮性：一个组件崩溃不影响其他组件
- 缺点
  - 构建放弃了对系统计算的控制
  - 系统依赖中心化的“电话簿”，可能存在全局性能和资源管理问题



### 事件系统派遣机制 - 调度机制

<img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611215112.png" style="zoom: 50%;" />

#### 1 无独立调度模块的事件系统 - 被观察者/观察者模式

- 每一个模块都允许其他模块向自己所能发送的某些消息表明兴趣
- 当某一模块发出某一事件时，它自动将这些事件发布给那些曾经向自己注册过此事件的模块

#### 2 带有独立派谴模块的事件管理器

**事件派遣模块**是负责接收到来的事件并派遣它们到其它模块。

##### :one: 全广播式

**无目的**广播，接受者**自行决定**是否加以处理或者简单抛弃。

##### :two: 选择广播式

派遣模块将事件送到那些**已经注册**的模块中。

两种策略：

- **点对点模式：基于消息队列**

  - 消息只能够被唯一的消费者所消费，消费之后即从队列中删除

  <img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611215505.png" style="zoom: 33%;" />

- **发布-订阅模式**

  - 一个事件可以被多个订阅者消费

  <img src="https://raw.githubusercontent.com/Kaiming-Y/picgo_images/master/img/20240611215604.png" style="zoom:33%;" />







